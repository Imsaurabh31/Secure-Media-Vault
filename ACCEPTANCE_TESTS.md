# Acceptance Test Scenarios\n\nThese 8 behaviors demonstrate the security and functionality requirements:\n\n## 1. Replay Protection (Idempotent Finalize)\n\n**Test**: Call `finalizeUpload` twice with same parameters\n\n```javascript\n// First call succeeds\nconst result1 = await finalizeUpload({\n  assetId: 'asset-123',\n  clientSha256: 'abc123...',\n  version: 1\n});\n\n// Second call returns same result (idempotent)\nconst result2 = await finalizeUpload({\n  assetId: 'asset-123', \n  clientSha256: 'abc123...',\n  version: 1\n});\n\n// Both return same asset, no double processing\nassert(result1.id === result2.id);\nassert(result1.version === result2.version);\n```\n\n**Expected**: Second call returns existing asset without re-processing\n\n## 2. Hash Mismatch Detection\n\n**Test**: Upload file, then finalize with wrong hash\n\n```javascript\n// Upload file normally\nconst ticket = await createUploadUrl({\n  filename: 'test.jpg',\n  mime: 'image/jpeg', \n  size: 1024\n});\n\n// PUT file to uploadUrl...\n\n// Finalize with incorrect hash\ntry {\n  await finalizeUpload({\n    assetId: ticket.assetId,\n    clientSha256: 'wrong-hash-value',\n    version: 1\n  });\n} catch (error) {\n  assert(error.extensions.code === 'INTEGRITY_ERROR');\n}\n\n// Asset should be marked as corrupt\nconst asset = await getAsset(ticket.assetId);\nassert(asset.status === 'corrupt');\n```\n\n**Expected**: Asset marked as corrupt, error thrown\n\n## 3. RLS Enforcement (Cross-User Access)\n\n**Test**: User B tries to access User A's asset\n\n```javascript\n// User A uploads file\nconst userAToken = 'user-a-jwt-token';\nconst asset = await createAndUploadFile(userAToken);\n\n// User B tries to get download URL\nconst userBToken = 'user-b-jwt-token';\ntry {\n  await getDownloadUrl(asset.id, userBToken);\n} catch (error) {\n  assert(error.extensions.code === 'FORBIDDEN');\n  assert(error.message === 'Access denied');\n}\n```\n\n**Expected**: 403 Forbidden error, no access granted\n\n## 4. TTL Expiration (90-120s Links)\n\n**Test**: Download URL expires after TTL\n\n```javascript\n// Get download URL\nconst { url, expiresAt } = await getDownloadUrl(assetId);\nconst expiryTime = new Date(expiresAt);\nconst now = new Date();\n\n// Should expire in ~90-120 seconds\nconst ttlSeconds = (expiryTime - now) / 1000;\nassert(ttlSeconds >= 85 && ttlSeconds <= 125);\n\n// Wait for expiration\nawait sleep(ttlSeconds * 1000 + 5000);\n\n// URL should now fail\nconst response = await fetch(url);\nassert(response.status === 403 || response.status === 404);\n```\n\n**Expected**: URL works initially, fails after expiration\n\n## 5. Version Conflict (409 Handling)\n\n**Test**: Rename same asset from two browser tabs\n\n```javascript\n// Tab 1: Get asset\nconst asset1 = await getAsset('asset-123');\n\n// Tab 2: Get same asset  \nconst asset2 = await getAsset('asset-123');\n\n// Tab 1: Rename successfully\nconst updated1 = await renameAsset({\n  assetId: 'asset-123',\n  filename: 'new-name-1.jpg',\n  version: asset1.version\n});\n\n// Tab 2: Try to rename (should fail)\ntry {\n  await renameAsset({\n    assetId: 'asset-123', \n    filename: 'new-name-2.jpg',\n    version: asset2.version // Stale version\n  });\n} catch (error) {\n  assert(error.extensions.code === 'VERSION_CONFLICT');\n}\n\n// Tab 2: Refetch and retry\nconst refreshed = await getAsset('asset-123');\nconst updated2 = await renameAsset({\n  assetId: 'asset-123',\n  filename: 'new-name-2.jpg', \n  version: refreshed.version // Fresh version\n});\n\nassert(updated2.filename === 'new-name-2.jpg');\n```\n\n**Expected**: First rename succeeds, second gets 409, retry succeeds\n\n## 6. Upload Cancel + Retry\n\n**Test**: Cancel upload mid-progress, then retry\n\n```javascript\n// Start upload\nconst uploadPromise = startUpload(file);\n\n// Cancel after 50% progress\nsetTimeout(() => {\n  uploadManager.cancelUpload(assetId);\n}, 1000);\n\ntry {\n  await uploadPromise;\n} catch (error) {\n  assert(error.name === 'AbortError');\n}\n\n// Retry with same assetId\nconst retryResult = await retryUpload(assetId, file);\nassert(retryResult.status === 'ready');\n```\n\n**Expected**: Cancel aborts upload, retry succeeds with same ID\n\n## 7. MIME Allowlist (Executable Rejection)\n\n**Test**: Try to upload .exe file renamed as .jpg\n\n```javascript\n// Create fake image file (actually executable)\nconst fakeImage = new File(\n  [new Uint8Array([0x4D, 0x5A])], // PE header (not JPEG)\n  'malware.jpg',\n  { type: 'image/jpeg' }\n);\n\n// Upload should be rejected during finalization\ntry {\n  const ticket = await createUploadUrl({\n    filename: 'malware.jpg',\n    mime: 'image/jpeg',\n    size: fakeImage.size\n  });\n  \n  // PUT file...\n  \n  await finalizeUpload({\n    assetId: ticket.assetId,\n    clientSha256: await computeHash(fakeImage),\n    version: 1\n  });\n} catch (error) {\n  assert(error.extensions.code === 'INTEGRITY_ERROR');\n  assert(error.message.includes('MIME type verification failed'));\n}\n```\n\n**Expected**: Server rejects file based on magic bytes\n\n## 8. Path Safety (Traversal Prevention)\n\n**Test**: Try filename with path traversal\n\n```javascript\n// Attempt directory traversal\nconst maliciousFilenames = [\n  '../../../etc/passwd',\n  '..\\\\..\\\\windows\\\\system32\\\\config\\\\sam',\n  'normal.jpg/../../../secret.txt',\n  'file\\u0000.jpg', // Null byte injection\n  'très_spéciał_fîlé.jpg' // Unicode normalization\n];\n\nfor (const filename of maliciousFilenames) {\n  try {\n    const ticket = await createUploadUrl({\n      filename,\n      mime: 'image/jpeg',\n      size: 1024\n    });\n    \n    // Check that storage path is safe\n    assert(!ticket.storagePath.includes('..'));\n    assert(!ticket.storagePath.includes('//'));\n    assert(ticket.storagePath.startsWith(userId));\n    \n    // Filename should be normalized\n    const normalizedName = ticket.storagePath.split('/').pop();\n    assert(!normalizedName.includes('../'));\n    assert(normalizedName.length <= 255);\n    \n  } catch (error) {\n    // Some may be rejected entirely\n    assert(error.extensions.code === 'BAD_REQUEST');\n  }\n}\n```\n\n**Expected**: Paths are sanitized, no traversal possible\n\n## Running Tests\n\n```bash\n# Run automated tests\nnpm test\n\n# Manual testing via UI\nnpm run dev\n\n# Enable dev tools for network simulation\n# Toggle \"Dev Tools\" in bottom right\n# Enable 15% failure rate\n# Test upload retry behavior\n```\n\n## Video Demonstration\n\nRecord a 3-minute video showing:\n1. Sign up and upload files\n2. Demonstrate each of the 8 test scenarios\n3. Show dev tools network simulation\n4. Verify security behaviors in browser dev tools\n\nThe video should prove that all security requirements are implemented and working correctly.\n