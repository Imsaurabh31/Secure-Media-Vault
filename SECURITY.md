# Security Model & Threat Analysis\n\n## Threat Model\n\n### Assets Protected\n- User-uploaded media files (images, PDFs)\n- File metadata and access permissions\n- Download URLs and access logs\n\n### Threat Actors\n- **Malicious Users**: Attempting to access others' files\n- **Network Attackers**: Intercepting or replaying requests\n- **Malicious Files**: Attempting path traversal or MIME spoofing\n\n## Security Controls\n\n### 1. Replay Attack Prevention\n**Threat**: Reusing upload tickets or download URLs\n\n**Controls**:\n- Single-use upload tickets with cryptographic nonces\n- Tickets bound to exact (userId, storagePath, mime, size, nonce)\n- Idempotent `finalizeUpload()` prevents double-processing\n- Short TTL on all signed URLs (10min upload, 90s download)\n\n**Implementation**:\n```sql\n-- Ticket can only be used once\nused boolean not null default false\n-- Unique nonce prevents replay\nnonce text not null unique\n```\n\n### 2. Access Control (RLS)\n**Threat**: Unauthorized access to files\n\n**Controls**:\n- Row-Level Security on all database tables\n- Private storage bucket (no public access)\n- Owner-only access with explicit sharing\n- Authentication required for all operations\n\n**Implementation**:\n```sql\ncreate policy \"owner can crud own assets\"\non public.asset for all to authenticated\nusing (owner_id = auth.uid())\nwith check (owner_id = auth.uid());\n```\n\n### 3. File Integrity\n**Threat**: File corruption or tampering\n\n**Controls**:\n- Client-side SHA-256 computation before upload\n- Server-side hash verification via Edge Function\n- Hash mismatch marks asset as \"corrupt\"\n- MIME type validation using magic bytes\n\n**Implementation**:\n```typescript\n// Client computes hash\nconst clientSha256 = await computeFileHash(file);\n\n// Server verifies via Edge Function\nconst { sha256: serverSha256 } = await hashFunction(storagePath);\nif (serverSha256 !== clientSha256) {\n  markAsCorrupt(assetId);\n}\n```\n\n### 4. Path Traversal Prevention\n**Threat**: Directory traversal attacks (../../../etc/passwd)\n\n**Controls**:\n- Filename normalization and sanitization\n- Path validation (no .. or // sequences)\n- Structured storage paths: `{userId}/{year}/{month}/{assetId}-{filename}`\n- Unicode normalization (NFD)\n\n**Implementation**:\n```typescript\nfunction normalizeFilename(filename: string): string {\n  return filename\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // Remove diacritics\n    .replace(/[^a-zA-Z0-9.-]/g, '_') // Replace unsafe chars\n    .replace(/\\.+/g, '.') // Collapse multiple dots\n    .substring(0, 255); // Limit length\n}\n```\n\n### 5. MIME Type Validation\n**Threat**: Malicious files disguised as images\n\n**Controls**:\n- Server-side allowlist: only JPEG, PNG, WebP, PDF\n- Magic byte verification (not just extension)\n- Rejection of executable file types\n\n**Implementation**:\n```typescript\nconst MAGIC_BYTES = {\n  'image/jpeg': [0xFF, 0xD8, 0xFF],\n  'image/png': [0x89, 0x50, 0x4E, 0x47],\n  // ...\n};\n\nfunction verifyMimeType(buffer: ArrayBuffer, mime: string): boolean {\n  const bytes = new Uint8Array(buffer);\n  const expected = MAGIC_BYTES[mime];\n  return expected?.every((byte, i) => bytes[i] === byte) ?? false;\n}\n```\n\n### 6. Concurrency Control\n**Threat**: Race conditions and lost updates\n\n**Controls**:\n- Optimistic locking with version numbers\n- 409 Conflict responses on stale versions\n- Client-side reconciliation and retry\n\n**Implementation**:\n```sql\n-- Update only if version matches\nUPDATE asset SET filename = $1, version = version + 1\nWHERE id = $2 AND version = $3;\n\n-- Returns 0 rows if version mismatch\n```\n\n### 7. Audit & Monitoring\n**Threat**: Undetected unauthorized access\n\n**Controls**:\n- Download audit logging\n- Structured error logging\n- Failed access attempt tracking\n\n**Implementation**:\n```sql\n-- Log every download request\nINSERT INTO download_audit (asset_id, user_id, at)\nVALUES ($1, $2, now());\n```\n\n## Trade-offs & Design Decisions\n\n### TTL = 90 seconds\n**Rationale**: Balance between security and usability\n- **Pro**: Minimizes exposure window if URLs leak\n- **Con**: Users must download quickly\n- **Alternative**: Configurable TTL per asset type\n\n### Client-side Hashing\n**Rationale**: Early corruption detection + reduced server load\n- **Pro**: Fails fast, offloads computation to client\n- **Con**: Large files take time to hash in browser\n- **Alternative**: Streaming hash during upload\n\n### Single Storage Bucket\n**Rationale**: Simpler RLS and path management\n- **Pro**: Unified access control, easier backup\n- **Con**: All files in same namespace\n- **Alternative**: Per-user buckets (more complex)\n\n### Edge Function for Hashing\n**Rationale**: Secure server-side verification\n- **Pro**: Untrusted by client, uses service role\n- **Con**: Additional latency and complexity\n- **Alternative**: Hash in main API (less secure)\n\n## Residual Risks\n\n### 1. Supabase Infrastructure\n**Risk**: Compromise of underlying platform\n**Mitigation**: Trust in Supabase security + regular backups\n\n### 2. Service Role Key Exposure\n**Risk**: Admin access if key leaks\n**Mitigation**: Environment variable protection + rotation\n\n### 3. Client-side Vulnerabilities\n**Risk**: XSS or malicious browser extensions\n**Mitigation**: CSP headers + secure coding practices\n\n### 4. Shared User Trust\n**Risk**: Shared users may leak download URLs\n**Mitigation**: Short TTL + audit logging + user education\n\n## Security Testing\n\nThe project includes automated tests for:\n- ✅ Version conflict handling\n- ✅ Hash integrity verification  \n- ✅ RLS policy enforcement\n- ✅ Upload ticket replay prevention\n- ✅ MIME type validation\n- ✅ Path sanitization\n\n## Compliance Considerations\n\n- **GDPR**: User data deletion via cascade constraints\n- **SOC 2**: Audit logging and access controls\n- **OWASP Top 10**: Protection against injection, broken access control\n