import { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// Mock fetch for edge function calls\nglobal.fetch = vi.fn();\n\n// Mock Supabase client\nconst mockSupabase = {\n  auth: {\n    getUser: vi.fn(),\n    admin: {\n      listUsers: vi.fn()\n    }\n  },\n  from: vi.fn(() => ({\n    select: vi.fn().mockReturnThis(),\n    insert: vi.fn().mockReturnThis(),\n    update: vi.fn().mockReturnThis(),\n    delete: vi.fn().mockReturnThis(),\n    eq: vi.fn().mockReturnThis(),\n    single: vi.fn(),\n    upsert: vi.fn()\n  })),\n  storage: {\n    from: vi.fn(() => ({\n      createSignedUploadUrl: vi.fn(),\n      createSignedUrl: vi.fn(),\n      download: vi.fn(),\n      remove: vi.fn()\n    }))\n  }\n};\n\nvi.mock('@supabase/supabase-js', () => ({\n  createClient: () => mockSupabase\n}));\n\n// Import resolvers after mocking\nimport { resolvers } from './resolvers';\n\ndescribe('GraphQL Resolvers Security Tests', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('Version Conflict Handling', () => {\n    it('should return VERSION_CONFLICT error when version mismatch occurs', async () => {\n      const mockUser = { id: 'user-123' };\n      mockSupabase.auth.getUser.mockResolvedValue({ \n        data: { user: mockUser }, \n        error: null \n      });\n\n      // Mock version conflict error from database\n      const mockError = { code: '23505', message: 'Version conflict detected' };\n      mockSupabase.from().single.mockRejectedValue(mockError);\n\n      try {\n        await resolvers.Mutation.renameAsset(\n          null,\n          { assetId: 'asset-123', filename: 'new-name.jpg', version: 1 },\n          { token: 'valid-token' }\n        );\n        expect.fail('Should have thrown VERSION_CONFLICT error');\n      } catch (error: any) {\n        expect(error.extensions.code).toBe('VERSION_CONFLICT');\n        expect(error.message).toBe('Version conflict');\n      }\n    });\n  });\n\n  describe('Hash Integrity Verification', () => {\n    it('should mark asset as corrupt when hash mismatch occurs', async () => {\n      const mockUser = { id: 'user-123' };\n      mockSupabase.auth.getUser.mockResolvedValue({ \n        data: { user: mockUser }, \n        error: null \n      });\n\n      const mockTicket = {\n        asset_id: 'asset-123',\n        user_id: 'user-123',\n        storage_path: 'user-123/2024/01/asset-123-file.jpg',\n        size: 1000,\n        mime: 'image/jpeg',\n        used: false,\n        expires_at: new Date(Date.now() + 10000).toISOString()\n      };\n\n      mockSupabase.from().single.mockResolvedValue({ \n        data: mockTicket, \n        error: null \n      });\n\n      // Mock edge function response with different hash\n      (global.fetch as any).mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve({\n          sha256: 'server-computed-hash-different',\n          size: 1000\n        })\n      });\n\n      // Mock file download for MIME verification\n      mockSupabase.storage.from().download.mockResolvedValue({\n        data: new Blob([new Uint8Array([0xFF, 0xD8, 0xFF])]), // JPEG magic bytes\n        error: null\n      });\n\n      try {\n        await resolvers.Mutation.finalizeUpload(\n          null,\n          { \n            assetId: 'asset-123', \n            clientSha256: 'client-computed-hash-original', \n            version: 1 \n          },\n          { token: 'valid-token' }\n        );\n        expect.fail('Should have thrown INTEGRITY_ERROR');\n      } catch (error: any) {\n        expect(error.extensions.code).toBe('INTEGRITY_ERROR');\n        expect(error.message).toBe('Hash mismatch');\n      }\n\n      // Verify asset was marked as corrupt\n      expect(mockSupabase.from().update).toHaveBeenCalledWith({ status: 'corrupt' });\n    });\n  });\n\n  describe('RLS Enforcement', () => {\n    it('should deny access to assets not owned by user', async () => {\n      const mockUser = { id: 'user-b' };\n      mockSupabase.auth.getUser.mockResolvedValue({ \n        data: { user: mockUser }, \n        error: null \n      });\n\n      // Mock asset owned by different user with no sharing\n      mockSupabase.from().single.mockResolvedValue({ \n        data: {\n          id: 'asset-123',\n          owner_id: 'user-a', // Different owner\n          status: 'ready',\n          asset_share: [] // No sharing\n        }, \n        error: null \n      });\n\n      try {\n        await resolvers.Query.getDownloadUrl(\n          null,\n          { assetId: 'asset-123' },\n          { token: 'valid-token' }\n        );\n        expect.fail('Should have thrown FORBIDDEN error');\n      } catch (error: any) {\n        expect(error.extensions.code).toBe('FORBIDDEN');\n        expect(error.message).toBe('Access denied');\n      }\n    });\n  });\n\n  describe('Upload Ticket Validation', () => {\n    it('should prevent replay attacks with used tickets', async () => {\n      const mockUser = { id: 'user-123' };\n      mockSupabase.auth.getUser.mockResolvedValue({ \n        data: { user: mockUser }, \n        error: null \n      });\n\n      const mockUsedTicket = {\n        asset_id: 'asset-123',\n        user_id: 'user-123',\n        used: true, // Already used\n        expires_at: new Date(Date.now() + 10000).toISOString()\n      };\n\n      mockSupabase.from().single.mockResolvedValue({ \n        data: mockUsedTicket, \n        error: null \n      });\n\n      // Mock existing asset for idempotent response\n      const mockAsset = {\n        id: 'asset-123',\n        status: 'ready',\n        version: 2\n      };\n      \n      mockSupabase.from().single.mockResolvedValueOnce({ \n        data: mockUsedTicket, \n        error: null \n      }).mockResolvedValueOnce({\n        data: mockAsset,\n        error: null\n      });\n\n      const result = await resolvers.Mutation.finalizeUpload(\n        null,\n        { assetId: 'asset-123', clientSha256: 'some-hash', version: 1 },\n        { token: 'valid-token' }\n      );\n\n      // Should return existing asset (idempotent)\n      expect(result).toEqual(mockAsset);\n      \n      // Should not call edge function for hash verification\n      expect(global.fetch).not.toHaveBeenCalled();\n    });\n  });\n});